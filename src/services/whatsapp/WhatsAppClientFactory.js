const { Client, LocalAuth } = require('whatsapp-web.js');\nconst qrcode = require('qrcode');\nconst fs = require('fs');\nconst path = require('path');\nconst Logger = require('../../utils/Logger');\n\n/**\n * Factory for creating and managing WhatsApp clients\n * Implements Factory Pattern for client creation\n */\nclass WhatsAppClientFactory {\n    constructor() {\n        this.clients = new Map(); // sessionId => { client, sessionData }\n        this.logger = new Logger('WhatsAppClientFactory');\n    }\n\n    /**\n     * Generate unique session ID\n     */\n    generateSessionId(userId, placeId) {\n        return `session_${userId}_${placeId}_${Date.now()}`;\n    }\n\n    /**\n     * Create new WhatsApp client instance\n     */\n    async createClient(sessionId) {\n        try {\n            this.logger.info(`Creating new WhatsApp client for session: ${sessionId}`);\n\n            const authPath = path.join(__dirname, '../../../.wwebjs_auth', `session-${sessionId}`);\n\n            const client = new Client({\n                authStrategy: new LocalAuth({ clientId: sessionId }),\n                puppeteer: { \n                    headless: true,\n                    args: [\n                        '--no-sandbox', \n                        '--disable-setuid-sandbox',\n                        '--disable-dev-shm-usage',\n                        '--disable-accelerated-2d-canvas',\n                        '--no-first-run',\n                        '--no-zygote',\n                        '--disable-gpu'\n                    ] \n                }\n            });\n\n            return client;\n        } catch (error) {\n            this.logger.error(`Error creating client for session ${sessionId}:`, error);\n            throw new Error(`Failed to create WhatsApp client: ${error.message}`);\n        }\n    }\n\n    /**\n     * Setup client event handlers\n     */\n    setupClientEventHandlers(client, sessionId, eventHandlers = {}) {\n        this.logger.info(`Setting up event handlers for session: ${sessionId}`);\n\n        // QR Code event\n        client.on('qr', async (qr) => {\n            try {\n                this.logger.info(`QR code generated for session: ${sessionId}`);\n                const qrDataURL = await qrcode.toDataURL(qr);\n                if (eventHandlers.onQR) {\n                    await eventHandlers.onQR(qrDataURL);\n                }\n            } catch (error) {\n                this.logger.error(`Error generating QR for ${sessionId}:`, error);\n            }\n        });\n\n        // Authentication events\n        client.on('authenticated', async () => {\n            try {\n                this.logger.success(`Session ${sessionId} authenticated`);\n                if (eventHandlers.onAuthenticated) {\n                    await eventHandlers.onAuthenticated();\n                }\n            } catch (error) {\n                this.logger.error(`Error in authenticated event for ${sessionId}:`, error);\n            }\n        });\n\n        client.on('loading_screen', async () => {\n            try {\n                this.logger.info(`Session ${sessionId} loading screen`);\n                if (eventHandlers.onLoadingScreen) {\n                    await eventHandlers.onLoadingScreen();\n                }\n            } catch (error) {\n                this.logger.error(`Error in loading_screen event for ${sessionId}:`, error);\n            }\n        });\n\n        // Ready event\n        client.on('ready', async () => {\n            try {\n                this.logger.success(`Session ${sessionId} is ready!`);\n                const clientInfo = client.info;\n                if (eventHandlers.onReady) {\n                    await eventHandlers.onReady(clientInfo);\n                }\n            } catch (error) {\n                this.logger.error(`Error in ready event for ${sessionId}:`, error);\n            }\n        });\n\n        // Error events\n        client.on('auth_failure', async (message) => {\n            try {\n                this.logger.error(`Auth failure for ${sessionId}:`, { message });\n                if (eventHandlers.onAuthFailure) {\n                    await eventHandlers.onAuthFailure(message);\n                }\n                await this.cleanupClient(sessionId);\n            } catch (error) {\n                this.logger.error(`Error handling auth failure for ${sessionId}:`, error);\n            }\n        });\n\n        client.on('disconnected', async (reason) => {\n            try {\n                this.logger.warn(`Session ${sessionId} disconnected:`, { reason });\n                if (eventHandlers.onDisconnected) {\n                    await eventHandlers.onDisconnected(reason);\n                }\n                await this.cleanupClient(sessionId);\n            } catch (error) {\n                this.logger.error(`Error handling disconnect for ${sessionId}:`, error);\n            }\n        });\n\n        return client;\n    }\n\n    /**\n     * Store client in memory\n     */\n    storeClient(sessionId, client, sessionData) {\n        this.clients.set(sessionId, { client, sessionData });\n        this.logger.info(`Client stored for session: ${sessionId}`);\n    }\n\n    /**\n     * Get client by session ID\n     */\n    getClient(sessionId) {\n        return this.clients.get(sessionId)?.client || null;\n    }\n\n    /**\n     * Get client data by session ID\n     */\n    getClientData(sessionId) {\n        return this.clients.get(sessionId) || null;\n    }\n\n    /**\n     * Check if client exists\n     */\n    hasClient(sessionId) {\n        return this.clients.has(sessionId);\n    }\n\n    /**\n     * Remove client from memory\n     */\n    removeClient(sessionId) {\n        if (this.clients.has(sessionId)) {\n            this.clients.delete(sessionId);\n            this.logger.info(`Client removed from memory for session: ${sessionId}`);\n        }\n    }\n\n    /**\n     * Cleanup client and associated files\n     */\n    async cleanupClient(sessionId) {\n        try {\n            this.logger.start(`Cleaning up client for session: ${sessionId}`);\n\n            // Remove from memory\n            this.removeClient(sessionId);\n\n            // Remove auth files\n            const authPath = path.join(__dirname, '../../../.wwebjs_auth', `session-${sessionId}`);\n            if (fs.existsSync(authPath)) {\n                fs.rmSync(authPath, { recursive: true, force: true });\n                this.logger.info(`Deleted session folder for ${sessionId}`);\n            }\n\n            this.logger.complete(`Client cleanup for session: ${sessionId}`);\n        } catch (error) {\n            this.logger.error(`Error cleaning up session ${sessionId}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Get all active sessions\n     */\n    getActiveSessions() {\n        return Array.from(this.clients.keys());\n    }\n\n    /**\n     * Get client statistics\n     */\n    getStats() {\n        return {\n            total_active_clients: this.clients.size,\n            active_sessions: this.getActiveSessions()\n        };\n    }\n\n    /**\n     * Gracefully shutdown all clients\n     */\n    async shutdownAllClients() {\n        this.logger.info('Shutting down all WhatsApp clients...');\n        \n        const shutdownPromises = [];\n        for (const [sessionId, { client }] of this.clients) {\n            shutdownPromises.push(\n                client.destroy().catch(error => \n                    this.logger.error(`Error destroying client ${sessionId}:`, error)\n                )\n            );\n        }\n\n        await Promise.allSettled(shutdownPromises);\n        this.clients.clear();\n        \n        this.logger.success('All clients shut down successfully');\n    }\n}\n\nmodule.exports = WhatsAppClientFactory;\n