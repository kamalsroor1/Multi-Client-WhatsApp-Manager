const Logger = require('../../utils/Logger');\nconst ContactService = require('../contact/ContactService');\n\n/**\n * Service for managing background contact fetching\n * Implements Single Responsibility Principle\n */\nclass ContactFetchingService {\n    constructor() {\n        this.logger = new Logger('ContactFetchingService');\n        this.contactService = new ContactService();\n    }\n\n    /**\n     * Fetch contacts in background with progress tracking\n     */\n    async fetchContactsInBackground(client, userId, placeId, sessionId, onProgressUpdate) {\n        try {\n            this.logger.start(`Background contact fetch for session ${sessionId}`);\n            \n            // Notify start of fetching\n            if (onProgressUpdate) {\n                await onProgressUpdate({\n                    status: 'fetching_contacts',\n                    progress: 0\n                });\n            }\n\n            // Get all contacts from WhatsApp\n            const contacts = await client.getContacts();\n            const validContacts = this.filterValidContacts(contacts);\n            \n            this.logger.info(`Found ${validContacts.length} valid contacts to process`);\n            \n            // Process contacts in batches\n            const contactsWithDetails = await this.processContactsInBatches(\n                validContacts, \n                client, \n                sessionId,\n                onProgressUpdate\n            );\n            \n            // Save contacts to database\n            this.logger.info(`Saving ${contactsWithDetails.length} contacts to database...`);\n            const savedContacts = await this.contactService.saveContacts(\n                userId, \n                placeId, \n                sessionId, \n                contactsWithDetails\n            );\n            \n            // Update final status\n            if (onProgressUpdate) {\n                await onProgressUpdate({\n                    status: 'connected',\n                    progress: 100,\n                    completed: true,\n                    total_contacts: savedContacts.length\n                });\n            }\n            \n            this.logger.complete(`Background contact fetch for session ${sessionId}: ${savedContacts.length} contacts`);\n            \n            return {\n                success: true,\n                total_contacts: savedContacts.length,\n                processed_contacts: contactsWithDetails.length\n            };\n            \n        } catch (error) {\n            this.logger.error(`Error in background contact fetch for session ${sessionId}:`, error);\n            \n            // Update error status\n            if (onProgressUpdate) {\n                await onProgressUpdate({\n                    status: 'connected',\n                    progress: 0,\n                    error: error.message\n                });\n            }\n            \n            throw error;\n        }\n    }\n\n    /**\n     * Filter valid WhatsApp contacts\n     */\n    filterValidContacts(contacts) {\n        return contacts.filter(\n            contact => contact.id?.server === 'c.us' && contact.isWAContact\n        );\n    }\n\n    /**\n     * Process contacts in batches to avoid overwhelming the system\n     */\n    async processContactsInBatches(validContacts, client, sessionId, onProgressUpdate) {\n        const contactsWithDetails = [];\n        const batchSize = 10; // Process 10 contacts at a time\n        const totalContacts = validContacts.length;\n        \n        for (let i = 0; i < validContacts.length; i += batchSize) {\n            const batch = validContacts.slice(i, i + batchSize);\n            \n            this.logger.debug(`Processing batch ${Math.ceil((i + 1) / batchSize)} of ${Math.ceil(totalContacts / batchSize)}`);\n            \n            // Process batch in parallel\n            const batchPromises = batch.map(contact => \n                this.processSingleContact(contact, client)\n            );\n            \n            // Wait for current batch to complete\n            const batchResults = await Promise.allSettled(batchPromises);\n            \n            // Extract successful results\n            const successfulResults = batchResults\n                .filter(result => result.status === 'fulfilled')\n                .map(result => result.value);\n                \n            contactsWithDetails.push(...successfulResults);\n            \n            // Update progress\n            const progress = Math.round(((i + batchSize) / totalContacts) * 100);\n            const currentProgress = Math.min(progress, 100);\n            \n            if (onProgressUpdate) {\n                await onProgressUpdate({\n                    status: 'fetching_contacts',\n                    progress: currentProgress\n                });\n            }\n            \n            this.logger.progress(\n                'Contact fetch progress', \n                Math.min(i + batchSize, totalContacts), \n                totalContacts\n            );\n            \n            // Small delay between batches to prevent overwhelming\n            if (i + batchSize < validContacts.length) {\n                await this.delay(100);\n            }\n        }\n        \n        return contactsWithDetails;\n    }\n\n    /**\n     * Process a single contact with timeout and error handling\n     */\n    async processSingleContact(contact, client) {\n        try {\n            // Get profile picture with timeout\n            const profilePicUrl = await this.getProfilePictureWithTimeout(\n                client, \n                contact.id._serialized, \n                5000\n            );\n            \n            return {\n                name: contact.name || contact.pushname || contact.verifiedName || '-',\n                number: contact.id.user,\n                whatsapp_id: contact.id._serialized,\n                profile_picture_url: profilePicUrl,\n                is_business: contact.isBusiness || false,\n                business_info: contact.businessProfile || {},\n                last_interaction: contact.lastSeen || null,\n                last_seen: contact.lastSeen || null\n            };\n        } catch (contactError) {\n            this.logger.warn(`Error getting details for contact ${contact.id.user}:`, contactError);\n            \n            // Still return basic contact info on error\n            return {\n                name: contact.name || contact.pushname || '-',\n                number: contact.id.user,\n                whatsapp_id: contact.id._serialized,\n                profile_picture_url: null,\n                is_business: false,\n                business_info: {},\n                last_interaction: null,\n                last_seen: null\n            };\n        }\n    }\n\n    /**\n     * Get profile picture with timeout\n     */\n    async getProfilePictureWithTimeout(client, whatsappId, timeoutMs = 5000) {\n        try {\n            const profilePicPromise = client.getProfilePicUrl(whatsappId);\n            \n            const timeoutPromise = new Promise((_, reject) => \n                setTimeout(() => reject(new Error('timeout')), timeoutMs)\n            );\n            \n            return await Promise.race([profilePicPromise, timeoutPromise]);\n        } catch (error) {\n            // Return null if profile picture fetch fails\n            return null;\n        }\n    }\n\n    /**\n     * Utility function for delays\n     */\n    async delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n     * Estimate time remaining for contact fetching\n     */\n    estimateTimeRemaining(processed, total, startTime) {\n        if (processed === 0) return null;\n        \n        const elapsed = Date.now() - startTime;\n        const avgTimePerContact = elapsed / processed;\n        const remaining = (total - processed) * avgTimePerContact;\n        \n        return {\n            estimated_remaining_ms: Math.round(remaining),\n            estimated_remaining_minutes: Math.round(remaining / 60000),\n            avg_time_per_contact_ms: Math.round(avgTimePerContact)\n        };\n    }\n\n    /**\n     * Get contact fetching statistics\n     */\n    getContactFetchingStats(validContacts, processedContacts, startTime) {\n        const endTime = Date.now();\n        const totalTime = endTime - startTime;\n        \n        return {\n            total_found: validContacts.length,\n            successfully_processed: processedContacts.length,\n            failed_to_process: validContacts.length - processedContacts.length,\n            total_time_ms: totalTime,\n            total_time_minutes: Math.round(totalTime / 60000),\n            avg_time_per_contact: Math.round(totalTime / processedContacts.length),\n            success_rate: Math.round((processedContacts.length / validContacts.length) * 100)\n        };\n    }\n}\n\nmodule.exports = ContactFetchingService;\n